---
layout: portfolio
title: Portfolio
hidden: comments
---

<style>
  .content-title {
      margin-top: 30px !important;
      margin-bottom: 0 !important;
  }

  .skil{
      display: flex !important;
      flex-flow: row wrap;
  }

  .skil > img{
      margin-left:0 !important;
      margin-right:2px !important;
      margin-bottom:2px !important;
      height: 22px;
  }

  ul.list-inside > li{
      margin-left:4px;
      text-indent: -18px;
      padding-left: 14px;
  }

  p {
      line-height: 1.55;
  }

  h3 {
  margin-top: 24px !important;
  margin-bottom: 12px !important;
  }



  @media print
  {
      .sidebar, .site-header, .site-header-inner, .site-nav, .site-footer, .site-footer-inner, hr
      {
          display: none !important;
          margin:0 !important;
      }

      #introduce{
          grid-column: span 4 / span 4
      }

      #projects, #experience{
          margin-top: 0px !important;
      }

      #print-start{
          padding-top: 24px;
      }

      .print-break{
          page-break-before:always;
          padding-top: 22px;
      }

      .page-content{
          padding-top: 0px !important;
          padding-bottom: 0px !important;
          padding-left: 24px !important;
          padding-right: 24px !important;
      }

      .page-content > .wrapper{
          padding-left: 0px !important;
          padding-right: 0px !important;
      }

      #print-contents{
          line-height: 1.55;
      }

      pre > code{
        padding: 10px !important;
      }
  }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tw-elements/dist/css/index.min.css"/>
<script src="https://cdn.tailwindcss.com"></script>

<!-- 1. 프로젝트 개요 (Overview) -->
<h2 class="mt-0" id="project-overview" style="margin-top: 0">MedOps 프로젝트 개요</h2>
<div class="">
  <div class="">
    <p>
      MedOps는 사용자에게 편리한 온라인 예약 경험을 제공하고 병원 관리자에게는 효율적인 운영 관리를 위해 백오피스를 제공하는 시스템입니다.

      이 프로젝트는 Java, Spring Boot 등 엔터프라이즈 환경에서 널리 사용되는 기술을 학습하고,
      헥사고날 아키텍처와 이벤트 소싱, CQRS 패턴을 실제 프로젝트에 적용하여 아키텍처 설계 역량을 강화하는 것을 목표로 했습니다.
      또한 예약 도메인을 분석하고 도메인 주도 설계 관점에서 견고한 모델을 구축하는 경험을 쌓고자 했습니다.
    </p>
  </div>
  <div class="">
    [ <a href="https://medops.vercel.app/" target="_blank"
         class="font-bold text-blue-600 hover:text-blue-800 underline">Live Demo</a> ]
    [ <a href="https://github.com/dooyeoung/medops" target="_blank"
         class="font-bold text-blue-600 hover:text-blue-800 underline">GitHub</a> ]
  </div>
</div>


<h2 class="" id="key-features" style="margin-bottom:0px !important">핵심 기능 및 구현 내용</h2>
<div>
  <!-- 예약 관리 시스템 -->
  <div class="mb-4">
    <h3 class="text-lg  mb-2" id="reservation-system">예약 관리 시스템</h3>
    <img src="assets/images/portfolio/admin_page.gif" alt="예약 관리 시스템 화면" class="rounded-lg border mb-2 w-10/12">
    <div class="">
      <p>
        예약자 목록을 날짜별로 구분하여 확인할 수 있고 하루 단위 스케쥴 관리가 가능합니다.
        예약의 생성부터 완료까지 모든 상태 변경을 이벤트로 기록하여 데이터의 변경 과정을 완벽하게 추적하는 이벤트 소싱 기반의 상태 관리입니다.
        이를 통해 특정 시점의 상태를 정교하게 복원할 수 있는 안정적인 시스템을 구축했습니다.
      </p>
    </div>
  </div>

  <!-- 실시간 알림 -->
  <div class="mb-4">
    <h3 class="text-lg mb-2" id="realtime-notification">실시간 알림 (SSE)</h3>
    <img src="assets/images/portfolio/admin_sse.gif" alt="실시간 알림 화면" class="rounded-lg border mb-2 w-10/12">
    <div class="">
      <p>
        WebSocket에 비해 가볍고 구현이 용이한 장점의 SseEmitter를 활용하여 서버에서 클라이언트로 단방향 데이터 푸시가 가능한 실시간 알림 기능을 구현했습니다.
        여러 관리자가 별도의 새로고침 없이 최신 예약 현황을 동기화할 수 있어, 다중 사용자 환경에서의 운영 효율성과 데이터 일관성을 크게 향상시켰습니다.
      </p>
    </div>
  </div>

  <!-- 관리자 대시보드 -->
  <div class="mb-4">
    <h3 class="text-lg mb-2" id="admin-dashboard">관리자 대시보드</h3>
    <img src="assets/images/portfolio/admin_dashboard.gif" alt="관리자 대시보드 화면" class="rounded-lg border mb-2 w-8/12">
    <div class="">
      <p>
        관리자 대시보드는 CQRS 패턴을 적용하여 복잡한 조회 요건을 효율적으로 처리하도록 설계했습니다.
        쓰기 모델과 분리된 읽기 전용 모델을 통해 실시간 예약 현황 및 매출 통계 조회의 성능을 최적화했습니다.
        또한, 조회된 통계 데이터는 EChart.js와 연동하여 동적인 차트로 시각화함으로써,
        관리자가 비즈니스 현황을 직관적으로 파악하고 데이터 기반의 의사결정을 내릴 수 있도록 지원합니다.
      </p>
    </div>
  </div>
</div>


<!-- 2. 시스템 아키텍처 (Architecture) -->
<h2 class="" id="architecture" >프로젝트 구조</h2>

<div class="">
  <!-- Hexagonal Architecture -->
  <div class="mb-4">
    <img src="assets/images/portfolio/hexagonal.png" alt="헥사고날 아키텍처 다이어그램" class="mb-2 rounded w-8/12">
    <h3 class="text-lg mb-2" id="hexagonal-architecture">헥사고날 아키텍처</h3>
    <p class="mb-2">
      복잡한 의료 도메인 로직을 외부 기술의 변경으로부터 보호하고, 테스트 가능한 설계를 만들기 위해 헥사고날 아키텍처를 선택했습니다.
      기존 레이어드 아키텍처에서는 서비스 레이어가 특정 기술에 의존하게 되어 테스트와 유지보수가 어려운 경우가 있었습니다.
    </p>
    <pre class="bg-gray-100 p-1 rounded text-xs mb-2 border border-gray-300"><code>// 레이어드 아키텍처 - 서비스가 외부 기능에 직접적으로 의존하게 됨
@Service
public class ReservationService {
    @Autowired private ReservationRepository repository;
    @Autowired private PaymentGateway paymentGateway;           // 결제 시스템
    @Autowired private NotificationService notificationService; // 알림 시스템
    @Autowired private HospitalSystem hospitalSystem;           // 병원 내부 시스템

    public void createReservation(ReservationDto dto) {
        // 결제 처리 - 구체적인 게이트웨이에 의존
        PaymentResult result = paymentGateway.charge(dto.getAmount());

        Reservation reservation = new Reservation(dto);
        reservation.confirm();
        repository.save(reservation);

        // 다양한 알림 서비스 직접 호출 - 강한 결합
        notificationService.send(dto.getPhone(), dto.getEmail(), "예약 확정");
        hospitalSystem.updateSchedule(reservation);
    }
}</code></pre>

    <p class="mb-2">
      헥사고날 아키텍처에서는 도메인 서비스가 인터페이스만 의존하여 외부 기술과 분리됩니다.
    </p>
    <pre class="bg-gray-100 p-1 rounded mb-2 text-xs border border-gray-300"><code>// 헥사고날 - 서비스가 구현체 대신 인터페이스를 의존하게 됨
@Service
@RequiredArgsConstructor
public class ReservationService {
    private final SaveReservationPort saveReservationPort;
    private final PaymentPort paymentPort;           // 결제 인터페이스
    private final NotificationPort notificationPort; // 알림 인터페이스
    private final HospitalPort hospitalPort;         // 병원 내부 시스템 인터페이스

    public void createReservation(CreateReservationCommand command) {
        // 결제 처리 - 인터페이스에만 의존
        PaymentResult result = paymentPort.processPayment(command.getAmount());

        Reservation reservation = Reservation.create(command);
        reservation.confirm();  // 도메인 로직
        saveReservationPort.save(reservation);

        // 알림 발송 - 포트로 추상화 (이메일/SMS 구현체는 어댑터에서)
        notificationPort.send(reservation);
        hospitalPort.updateSchedule(reservation);
    }
}</code></pre>

    <p class="mb-2">
      레이어드 아키텍처에서 Service를 직접 참조하면 해당 구현체에 강하게 결합되지만,
      헥사고날에서 Port인터페이스를 참조하면 이메일, SMS, 푸시 알림 등 어떤 구현체로도 비교적 자유롭게 교체할 수 있습니다.
      이런한 구조를 통해 MongoDB를 MySQL로 교체하는 상황에서도 어댑터만 바꾸면 됩니다
    </p>
    <div class="mb-2">
      <div>
        <pre class="bg-gray-100 p-1 rounded text-xs border border-gray-300"><code>@Component
@RequiredArgsConstructor
public class ReservationPersistenceAdapter implements LoadReservationPort {

    // private final ReservationDocumentRepository repository;
    private final ReservationJpaRepository repository;  // JPA로 변경
    private final ReservationConverter converter;

    @Override
    public List&lt;Reservation&gt; loadByDoctorId(String doctorId) {
        return repository.findAllByDoctorId(doctorId).stream()
            .map(converter::toDomain).toList();
    }
}</code></pre>
      </div>
    </div>
    <p class="mb-2">
    헥사고날 아키텍처를 사용하며 느낀 장점은 다음과 같습니다.
    <ol>
      <li>첫째, 도메인 로직이 프레임워크와 구현체에 독립적이어서 변경에 유연하고</li>
      <li>둘째, 인터페이스 기반으로 테스트용 Mock 구현체를 쉽게 만들 수 있어 빠른 단위 테스트가 가능하며</li>
      <li>셋째, 새로운 요구사항(알림 방식 변경, DB 교체 등)에 기존 비즈니스 로직 수정 없이 어댑터만 추가하면 됩니다.</li>
    </ol>
    실제로 개발 중에도 인메모리 구현체로 빠르게 검증하고, 운영에서는 실제 구현체로 교체하는 방식으로 생산성을 크게 높일 수 있었습니다.
    </p>
  </div>

  <!-- Event Sourcing Flow -->
  <div class="mb-4">
    <h3 class="text-lg mb-2 print-break" id="event-sourcing">이벤트 소싱 및 CQRS</h3>
    <p class="mb-2">
      전통적인 CRUD + 로그 방식으로도 충분히 구현 가능하지만, 이벤트 소싱만의 고유한 특성을 경험해보고 싶었습니다. <br>
      전통적인 방식에서는 현재 상태를 저장하는 테이블이 정답이고 로그는 참고용 정보였다면,
      이벤트 소싱에서는 이벤트 기록 자체가 정답이 되어 현재 상태를 언제든 다시 추출할 수 있습니다. <br>
      과거 임의 시점의 정확한 상태 재현이나 새로운 읽기 모델 생성이 매우 자연스럽게 이루어집니다. <br>
    </p>
    <p class="mb-2">
      의료 도메인에서는 법적으로도 모든 의료 행위와 변경 사항에 대한 완전한 기록 보존이 요구되므로
      이벤트 소싱의 감사 추적(Audit) 기능이 이러한 요구사항을 자연스럽게 만족시킵니다.
    </p>
    <p class="mb-2">
      실제로 이벤트 소싱을 적용한 결과, 환자 문의 시 "담당의사 응급수술로 인한 불가피한 예약 변경(2024.03.15 14:30, 간호사 김○○ 처리)"과 같은
      처리의 구현이 비교적 간단했습니다.
      과거 특정 시점의 상태를 정확히 재현할 수 있어 시스템 문제 발생 시 신속한 원인 분석과 복구가 가능해졌습니다.
    </p>
    <p>
      나아가 명령(Command)과 조회(Query)의 책임을 분리하는 CQRS 패턴과 결합하면,
      이벤트 구독을 통해 다양한 목적의 읽기 전용 모델을 유연하게 생성할 수 있습니다.

      <a href="https://blog.gangnamunni.com/post/saas-event-sourcing" target="_blank"
         class="text-sm text-blue-600 underline">시간여행이 가능한 시스템 아키텍처</a> 참고하여 작성했습니다.
    </p>

    <img src="assets/images/portfolio/event_sourcing.png" alt="이벤트 소싱 및 CQRS 흐름도" class="mb-4 rounded w-8/12">
    <div class="mb-2">상황별 이벤트 처리 간단한 동작 순서는 다음과 같습니다.</div>

    <ol class="list-decimal list-outside space-y-4 pl-4">
      <li>
        신규 예약 신청 (이벤트 발생)
        <ul class="list-disc list-outside mt-1 space-y-1 pl-4">
          <li><strong>CommandExecutor:</strong> 커맨드 처리 후 이벤트 생성</li>
          <li><strong>EventStore:</strong> 생성된 이벤트를 저장</li>
          <li><strong>EventPublisher:</strong> 이벤트 발행</li>
          <li><strong>EventListener:</strong> 구독 중인 View Model 최신화</li>
        </ul>
      </li>
      <li>
        기존 예약 접수 (상태 변경)
        <ul class="list-disc list-outside mt-1 space-y-1 pl-4">
          <li><strong>EventStore:</strong> 해당 예약의 과거 이벤트들을 모두 조회</li>
          <li><strong>EventHandler:</strong> 조회된 이벤트들을 순차적으로 적용하여 현재 상태(State) 재구성</li>
          <li><strong>CommandExecutor:</strong> 커맨드 처리 후 이벤트 생성</li>
          <li><strong>EventStore:</strong> 새로운 이벤트를 추가로 저장</li>
          <li><strong>EventListener:</strong> View Model 최신화</li>
        </ul>
      </li>
    </ol>
  </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/tw-elements/dist/js/index.min.js"></script>
