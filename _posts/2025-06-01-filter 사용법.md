---
layout: post
title: "스프링 부트 필터(Filter), 언제 어떻게 써야 할까? (@Component vs FilterRegistrationBean)"
subtitle: "서블릿 필터의 개념부터 실용적인 등록 방법, 실전 팁까지"
categories: "Spring Boot"
tags: ["Spring Boot", "Filter", "Servlet"]
sidebar: ['article-menu']
---

## 들어가며: 우리 앱의 든든한 문지기, 서블릿 필터

웹 애플리케이션을 개발하다 보면 여러 컨트롤러에 걸쳐 공통적으로 처리해야 할 작업들이 생깁니다. 예를 들어, 모든 요청에 대한 로깅, 특정 요청에 대한 인증/인가 처리, 요청/응답 데이터의 인코딩 등이죠. 이런 로직을 모든 컨트롤러 메서드에 일일이 작성하는 것은 끔찍한 중복과 유지보수 비용을 초래합니다.

바로 이럴 때, 우리 앱의 가장 앞 단에서 든든한 '문지기' 역할을 해주는 것이 바로 **서블릿 필터(Servlet Filter)**입니다. 필터는 이름 그대로 Dispatcher Servlet에 요청이 전달되기 전/후에 원하는 처리 작업을 거칠 수 있게 해주는 강력한 도구입니다.

이번 글에서는 스프링 부트 환경에서 이 필터를 어떻게 구현하고, 어떤 상황에 어떤 방식으로 등록하는 것이 가장 효과적인지 알아보겠습니다.

## 1. 기본 필터 만들어보기: 요청 시간 측정 로거

먼저 간단하면서도 실용적인 필터를 하나 만들어 보겠습니다. 모든 API 요청이 들어올 때 시작 시간을 기록하고, 요청 처리가 끝났을 때 종료 시간을 기록하여 총 소요 시간을 로그로 남기는 필터입니다.

`jakarta.servlet.Filter` 인터페이스를 구현하면 `init()`, `doFilter()`, `destroy()` 세 가지 메서드를 오버라이드해야 합니다.

- `init()`: 필터 인스턴스가 생성되고 초기화될 때 호출됩니다.
- `doFilter()`: 가장 중요한 메서드로, 실제 필터링 로직이 들어갑니다.
- `destroy()`: 필터 인스턴스가 소멸될 때 호출됩니다.

```java
import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import java.io.IOException;
import java.util.UUID;

@Slf4j
public class RequestLoggingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String requestURI = httpRequest.getRequestURI();
        String requestId = UUID.randomUUID().toString().substring(0, 8);

        log.info("REQUEST [{}][{}]", requestId, requestURI);
        long startTime = System.currentTimeMillis();

        try {
            // 다음 필터 또는 서블릿으로 요청 전달
            chain.doFilter(request, response);
        } finally {
            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;
            log.info("RESPONSE [{}][{}][{}ms]", requestId, requestURI, duration);
        }
    }
}
```
> **💡 잠깐!** `chain.doFilter(request, response)` 코드가 바로 필터의 핵심입니다. 이 코드를 기준으로 **전(pre-processing)**에는 요청 처리 전 공통 기능을, **후(post-processing)**에는 응답 처리 후 공통 기능을 수행할 수 있습니다.

## 2. 필터 등록하기: 두 가지 방법, 언제 무엇을 쓸까?

이제 위에서 만든 `RequestLoggingFilter`를 스프링 부트가 인식하도록 등록해야 합니다. 등록 방법은 크게 두 가지가 있으며, 각각의 장단점과 사용 사례가 명확합니다.

### 방법 1: `@Component` - 가장 간단하고 빠른 방법

가장 쉬운 방법은 필터 구현체에 `@Component` 어노테이션을 붙여 스프링 빈으로 등록하는 것입니다.

```java
// RequestLoggingFilter.java
import org.springframework.stereotype.Component;

@Component // 이 어노테이션 하나로 필터 등록 끝!
@Slf4j
public class RequestLoggingFilter implements Filter {
    // ... (doFilter 로직은 위와 동일)
}
```

- **언제 사용할까?**
  - 애플리케이션의 모든 요청(`/*`)에 대해 필터를 적용하고 싶을 때
  - 필터 간의 실행 순서가 중요하지 않거나, `@Order` 어노테이션으로 간단하게 제어할 수 있을 때
  - 빠르게 프로토타이핑하거나 간단한 공통 로깅 필터를 추가할 때 매우 유용합니다.

- **주의할 점:**
  - 특정 URL 패턴에만 필터를 적용하거나 세밀한 순서 제어가 어렵습니다.

### 방법 2: `FilterRegistrationBean` - 전문가를 위한 세밀한 제어

실무에서는 필터마다 적용할 URL 패턴이나 실행 순서를 명확하게 제어해야 하는 경우가 많습니다. 이럴 때 `FilterRegistrationBean`을 사용합니다.

`@Configuration` 클래스를 하나 만들고, `FilterRegistrationBean`을 반환하는 `@Bean` 메서드를 정의하면 됩니다.

```java
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean<RequestLoggingFilter> loggingFilter() {
        FilterRegistrationBean<RequestLoggingFilter> registrationBean = new FilterRegistrationBean<>();

        registrationBean.setFilter(new RequestLoggingFilter()); // 등록할 필터 지정
        registrationBean.addUrlPatterns("/api/*"); // '/api/'로 시작하는 URL에만 적용
        registrationBean.setOrder(1); // 필터 체인에서 1번 순서로 실행
        registrationBean.setName("RequestLoggingFilter"); // 필터 이름 지정

        return registrationBean;
    }
}
```

- **언제 사용할까?**
  - 인증/인가 필터처럼 특정 경로(`/api/*`, `/admin/*` 등)에만 적용해야 할 때
  - 여러 필터가 존재하여 실행 순서를 명확하게 정의해야 할 때 (e.g., 로깅 필터 -> 인증 필터 -> ... )
  - 특정 환경(개발/운영)에 따라 필터를 활성화/비활성화해야 할 때 (`setEnabled(boolean)`)

- **주의할 점:**
  - 코드가 조금 길어지지만, 설정이 중앙에서 관리되므로 유지보수성과 명시성이 훨씬 뛰어납니다.
  - `new RequestLoggingFilter()`로 필터를 생성하면 해당 필터는 스프링 컨테이너의 관리를 받지 못해 의존성 주입(`@Autowired`)이 불가능합니다. 만약 필터 내에서 다른 빈을 사용해야 한다면, 필터 클래스에도 `@Component`를 붙이고 `FilterRegistrationBean`에서는 `new`로 생성하는 대신 주입받아서 사용해야 합니다.

## 3. 결론 및 실전 팁

| 구분 | `@Component` 방식 | `FilterRegistrationBean` 방식 |
| :--- | :--- | :--- |
| **적용 범위** | 모든 URL (`/*`) | 특정 URL 패턴 지정 가능 |
| **실행 순서** | `@Order`로 제어 (제한적) | `setOrder`로 명시적 제어 (권장) |
| **편의성** | 매우 간편함 | 설정 코드 필요 |
| **추천 상황** | 간단한 글로벌 필터 | 세밀한 제어가 필요한 대부분의 실무 상황 |

**🚀 실전 팁: 필터 vs 인터셉터, 언제 뭘 쓸까?**

- **필터(Filter):** 서블릿 레벨에서 동작. 스프링 컨텍스트와 무관하게 동작하며, 주로 보안(Spring Security), 인코딩, 로깅 등 저수준의 공통 기능에 사용됩니다.
- **인터셉터(Interceptor):** 스프링 MVC 레벨(Dispatcher Servlet 이후)에서 동작. 컨트롤러에 대한 더 많은 정보(핸들러 메서드 등)에 접근할 수 있어, 비즈니스 로직과 가까운 인증/인가, 세션 체크 등에 더 적합합니다.

**결론적으로, "일단 `@Component`로 간단하게 시작하되, URL 패턴이나 순서 제어가 필요해지면 주저 없이 `FilterRegistrationBean`으로 전환하라"** 고 조언하고 싶습니다. 이것이 바로 깔끔하고 유지보수하기 좋은 코드를 만드는 지름길입니다.