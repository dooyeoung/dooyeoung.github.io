---
layout: post
title: "Celery 환경별 성능 테스트 및 비교"
categories: "Celery"
tags: ["celery", "performance", "testing", "aws", "sqs"]
sidebar: ['article-menu']
---

Celery를 사용할 때 최적의 성능을 내기 위해서는 사용하는 환경에 맞는 설정값을 찾는 것이 중요합니다. 특히 Broker로 어떤 메시지 큐를 사용하는지, `concurrency`와 `prefetch_multiplier` 설정은 어떻게 하는지에 따라 성능이 크게 달라질 수 있습니다.

이 글에서는 몇 가지 다른 환경에서 Celery 성능을 테스트하고 그 결과를 공유합니다.

### **테스트 환경 설정**

테스트를 위해 간단한 Celery 태스크와 실행을 위한 Django 커맨드를 작성했습니다.

#### **임시 태스크 생성**

5초 동안 대기하며 시작과 끝에 로그를 남기는 간단한 태스크입니다.

```python
from time import sleep
from uuid import uuid4

from celery import shared_task

from lemonbase.common.logger import logger as CommonLogger
from server.celery import TEST, TESTFIFO


@shared_task(queue=TESTFIFO)
def test_fifo_task():
    test()

@shared_task(queue=TEST)
def test_task():
    test()

def test():
    id = str(uuid4())
    CommonLogger.info(f'{id} start fifo')
    sleep(5)
    CommonLogger.info(f'{id} end fifo')
```

#### **워커 실행을 위한 커맨드 작성**

위에서 생성한 태스크를 10번 호출하는 Django 커맨드입니다.

```python
import traceback

from lemonbase.common.commands import CommonBaseCommand
from lemonbase.goal.tasks.test_task import test_task


class Command(CommonBaseCommand):
    def run(self, *args, **options) -> None:
        try:
            for _ in range(10):
                test_task.delay()
        except:
            traceback.print_exc()
```

#### **워커 실행**

테스트를 위해 다음과 같이 워커를 실행했습니다.

```bash
DJANGO_SETTINGS_MODULE='server.settings.local' celery -A server worker \
--loglevel=info \
-Q queue-express.fifo,queue-standard.fifo,dio-test.fifo,dio-test \
--concurrency=2
```

### **테스트 결과**

#### **1. 표준 SQS (visibility_timeout=60, prefetch_multiplier=12)**

- **결과:**
    - `--concurrency` 설정에 따라 최대 2개의 작업이 동시에 실행되었습니다.
    - 메시지를 받은 후 바로 작업이 시작되지 않는 경우가 있었습니다.
    - 총 14개의 메시지가 처리되었고, 그중 4건은 중복 처리되었습니다.

#### **2. FIFO SQS (visibility_timeout=60, prefetch_multiplier=12)**

- **결과:**
    - 작업이 끝나지 않았습니다.
    - `concurrency` 수에 맞게 작업은 진행되지만, 중간에 긴 공백 시간이 있었습니다.

#### **3. 표준 SQS (prefetch_multiplier=4, visibility_timeout=120, concurrency=8)**

- **결과:**
    - 메시지를 받은 후 바로 처리하지 못하는 현상이 발생했습니다.

#### **4. FIFO SQS (prefetch_multiplier=4, visibility_timeout=120, concurrency=8)**

- **결과:**
    - 10개의 작업을 받아왔지만, 약 30초가량의 공백 시간이 발견되었습니다.

#### **5. FIFO 높은 처리량 SQS (prefetch_multiplier=4, visibility_timeout=120, concurrency=8)**

- **결과:**
    - 메시지를 받은 후 바로 처리하지 못하는 현상이 있었습니다.

#### **6. Redis (prefetch_multiplier=4, visibility_timeout=120, concurrency=80, gevent)**

- **결과:**
    - 10개의 작업이 거의 동시에 시작되고 끝났으며, 약 5초가 소요되었습니다.

#### **7. FIFO SQS (prefetch_multiplier=10, visibility_timeout=120, concurrency=8, wait_time_seconds=0)**

- **결과:**
    - 약 5초가 소요되었습니다.
    - SQS Long Polling 설정을 비활성화(`wait_time_seconds=0`)했을 때 Redis와 비슷한 성능을 보였습니다.

### **결론**

테스트 결과, SQS를 Broker로 사용할 때는 `prefetch_multiplier`와 `visibility_timeout` 설정을 신중하게 조절해야 하며, 특히 FIFO 큐를 사용할 때는 예상치 못한 동작이 발생할 수 있음을 확인했습니다. 반면 Redis는 별다른 문제 없이 빠르고 안정적인 성능을 보여주었습니다.

Celery 환경을 구성할 때는 이와 같은 테스트를 통해 자신의 서비스에 가장 적합한 설정을 찾는 과정이 반드시 필요합니다.

